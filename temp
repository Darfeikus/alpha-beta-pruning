def calculate_move(self, depth):
        node = Node(self.puzzle[0], self.size)
        
        alpha = -sys.maxsize-1
        beta = sys.maxsize

        min_eval = [beta, None]
        good_kid = None

        temp = self.minimax(node,depth,alpha,beta,False)
        print(f"{temp[0]} {temp[1]}")

        for child in node.generate_children():
            evaluation = self.minimax(child,depth,alpha,beta,False)
            if evaluation[0] < min_eval[0]: good_kid = child
            min_eval = min(evaluation,min_eval,key=lambda e: e[0])

        if good_kid:
            return node.level - good_kid.level
        else:
            return 1